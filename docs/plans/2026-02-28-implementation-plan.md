# Content Manager Trik - Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a conversational trik that gathers content from blogs, articles, and newsletters, scores inspirations by user interests, and generates articles/LinkedIn/X posts in the user's voice.

**Architecture:** LangChain ReAct agent with 11 tools backed by TrikHub storage. Factory pattern for tools (receive storage via closure). Gmail API via googleapis for newsletter access.

**Tech Stack:** TypeScript, LangChain (`@langchain/core`, `@langchain/langgraph`, `@langchain/anthropic`), Zod, `@trikhub/sdk`, `googleapis` (Gmail API)

**Reference:** See `docs/plans/2026-02-28-content-manager-design.md` for full design

---

## Progress Tracker

| Phase | Status | Description |
|-------|--------|-------------|
| 1 | [x] | Project Foundation & Scaffold |
| 2 | [x] | Sources Management (3 tools) |
| 3 | [x] | Inspirations Management (3 tools) |
| 4 | [x] | Content Management (4 tools) |
| 5 | [x] | Gmail Integration (1 tool) |
| 6 | [ ] | Agent System Prompt & Polish |

**After each phase:** Commit, verify build, then safe to compact and continue.

---

## Phase 1: Project Foundation & Scaffold

**Goal:** Set up the project with all files from the MCP scaffold, fix known issues, create shared types and storage helper, establish the tool factory pattern.

**Stop point:** Project compiles with `npm run build`. All tool stubs return "Not implemented" but have correct Zod input schemas.

### Task 1.1: Write Scaffold Files

Write all files generated by `scaffold_trik`. These are the base files the MCP produced.

**Files to create:**
- `manifest.json`
- `package.json`
- `tsconfig.json`
- `.gitignore`
- `.trikhub/secrets.json`

**Step 1: Create manifest.json**

Write the full manifest as generated by the MCP `scaffold_trik` tool (the complete JSON output from the scaffold call). This includes all 11 tool definitions with their logTemplates and logSchemas, capabilities (storage, session), config (gmail credentials), and entry point.

**Step 2: Create package.json**

```json
{
  "name": "content-manager",
  "version": "0.1.0",
  "description": "Automates content gathering from blogs, articles, and newsletters, scores inspirations by user interests, and generates articles, LinkedIn posts, and X posts in the user's voice.",
  "type": "module",
  "main": "./dist/agent.js",
  "scripts": {
    "build": "tsc",
    "dev": "node --import tsx src/agent.ts",
    "clean": "rm -rf dist *.tsbuildinfo"
  },
  "dependencies": {
    "@trikhub/sdk": "latest",
    "@langchain/anthropic": "^0.3.0",
    "@langchain/core": "^0.3.0",
    "@langchain/langgraph": "^0.2.0",
    "zod": "^3.25.0"
  },
  "devDependencies": {
    "tsx": "^4.19.0",
    "typescript": "^5.7.0"
  }
}
```

**Step 3: Create tsconfig.json, .gitignore, .trikhub/secrets.json**

Use the exact content from the scaffold output.

**Step 4: Commit**

```bash
git add manifest.json package.json tsconfig.json .gitignore .trikhub/secrets.json
git commit -m "chore: add scaffold base files from TrikHub MCP"
```

---

### Task 1.2: Create Shared Types

**File:** Create `src/types.ts`

**Step 1: Write types file**

```typescript
export interface Source {
  id: string;
  type: 'blog' | 'article' | 'newsletter';
  identifier: string;
  title: string;
  addedAt: string;
  lastScannedAt: string | null;
}

export interface Inspiration {
  id: string;
  sourceId: string;
  title: string;
  description: string;
  url: string;
  score: number;
  addedAt: string;
}

export interface Content {
  id: string;
  type: 'article' | 'linkedin' | 'x_post';
  title: string;
  body: string;
  status: 'draft' | 'done';
  inspirationIds: string[];
  userPrompt: string;
  createdAt: string;
  updatedAt: string;
}

export type SourceType = Source['type'];
export type ContentType = Content['type'];
export type ContentStatus = Content['status'];
```

**Step 2: Commit**

```bash
git add src/types.ts
git commit -m "feat: add shared TypeScript interfaces for Source, Inspiration, Content"
```

---

### Task 1.3: Create Storage Helper

**File:** Create `src/storage.ts`

This module wraps the TrikHub storage API with typed CRUD operations for each entity. All tools will use this instead of raw storage calls.

**Note:** The exact TrikHub storage API shape (`.get()`, `.set()`, etc.) may need adjustment based on SDK docs. We're assuming a simple key-value store where values are JSON-serializable.

**Step 1: Write storage helper**

```typescript
import crypto from 'node:crypto';
import type { Source, Inspiration, Content } from './types.js';

// Storage interface - matches what TrikContext.storage provides
// May need adjustment based on actual @trikhub/sdk API
export interface TrikStorage {
  get(key: string): Promise<unknown>;
  set(key: string, value: unknown): Promise<void>;
}

function generateId(): string {
  return crypto.randomUUID();
}

// === Sources ===

export async function getSources(storage: TrikStorage): Promise<Source[]> {
  const data = await storage.get('sources');
  return (data as Source[]) || [];
}

export async function addSourceToStorage(
  storage: TrikStorage,
  source: Omit<Source, 'id' | 'addedAt' | 'lastScannedAt'>
): Promise<{ source: Source; status: 'added' | 'duplicate' }> {
  const sources = await getSources(storage);
  const existing = sources.find(
    (s) => s.identifier === source.identifier && s.type === source.type
  );
  if (existing) {
    return { source: existing, status: 'duplicate' };
  }
  const newSource: Source = {
    ...source,
    id: generateId(),
    addedAt: new Date().toISOString(),
    lastScannedAt: null,
  };
  sources.push(newSource);
  await storage.set('sources', sources);
  return { source: newSource, status: 'added' };
}

export async function removeSourceFromStorage(
  storage: TrikStorage,
  sourceId: string
): Promise<{ source: Source | null; status: 'removed' | 'not_found' }> {
  const sources = await getSources(storage);
  const index = sources.findIndex((s) => s.id === sourceId);
  if (index === -1) {
    return { source: null, status: 'not_found' };
  }
  const [removed] = sources.splice(index, 1);
  await storage.set('sources', sources);
  return { source: removed, status: 'removed' };
}

export async function updateSourceScanTime(
  storage: TrikStorage,
  sourceId: string
): Promise<void> {
  const sources = await getSources(storage);
  const source = sources.find((s) => s.id === sourceId);
  if (source) {
    source.lastScannedAt = new Date().toISOString();
    await storage.set('sources', sources);
  }
}

// === Inspirations ===

export async function getInspirations(storage: TrikStorage): Promise<Inspiration[]> {
  const data = await storage.get('inspirations');
  return (data as Inspiration[]) || [];
}

export async function addInspirationToStorage(
  storage: TrikStorage,
  inspiration: Omit<Inspiration, 'id' | 'addedAt'>
): Promise<{ inspiration: Inspiration; status: 'added' | 'duplicate' }> {
  const inspirations = await getInspirations(storage);
  const existing = inspirations.find((i) => i.url === inspiration.url);
  if (existing) {
    return { inspiration: existing, status: 'duplicate' };
  }
  const newInspiration: Inspiration = {
    ...inspiration,
    id: generateId(),
    addedAt: new Date().toISOString(),
  };
  inspirations.push(newInspiration);
  await storage.set('inspirations', inspirations);
  return { inspiration: newInspiration, status: 'added' };
}

export async function getInspirationById(
  storage: TrikStorage,
  id: string
): Promise<Inspiration | null> {
  const inspirations = await getInspirations(storage);
  return inspirations.find((i) => i.id === id) || null;
}

export interface InspirationFilters {
  query?: string;
  minScore?: number;
  maxScore?: number;
  dateFrom?: string;
  dateTo?: string;
  sourceId?: string;
  sortBy?: 'score' | 'date';
  limit?: number;
}

export function filterInspirations(
  inspirations: Inspiration[],
  filters: InspirationFilters
): Inspiration[] {
  let results = [...inspirations];

  if (filters.query) {
    const q = filters.query.toLowerCase();
    results = results.filter(
      (i) =>
        i.title.toLowerCase().includes(q) ||
        i.description.toLowerCase().includes(q)
    );
  }

  if (filters.minScore !== undefined) {
    results = results.filter((i) => i.score >= filters.minScore!);
  }

  if (filters.maxScore !== undefined) {
    results = results.filter((i) => i.score <= filters.maxScore!);
  }

  if (filters.dateFrom) {
    results = results.filter((i) => i.addedAt >= filters.dateFrom!);
  }

  if (filters.dateTo) {
    results = results.filter((i) => i.addedAt <= filters.dateTo!);
  }

  if (filters.sourceId) {
    results = results.filter((i) => i.sourceId === filters.sourceId);
  }

  if (filters.sortBy === 'score') {
    results.sort((a, b) => b.score - a.score);
  } else {
    results.sort((a, b) => b.addedAt.localeCompare(a.addedAt));
  }

  if (filters.limit) {
    results = results.slice(0, filters.limit);
  }

  return results;
}

// === Content ===

export async function getContentList(storage: TrikStorage): Promise<Content[]> {
  const data = await storage.get('content');
  return (data as Content[]) || [];
}

export async function addContentToStorage(
  storage: TrikStorage,
  content: Omit<Content, 'id' | 'createdAt' | 'updatedAt' | 'status'>
): Promise<Content> {
  const contentList = await getContentList(storage);
  const now = new Date().toISOString();
  const newContent: Content = {
    ...content,
    id: generateId(),
    status: 'draft',
    createdAt: now,
    updatedAt: now,
  };
  contentList.push(newContent);
  await storage.set('content', contentList);
  return newContent;
}

export async function getContentById(
  storage: TrikStorage,
  id: string
): Promise<Content | null> {
  const contentList = await getContentList(storage);
  return contentList.find((c) => c.id === id) || null;
}

export async function updateContentInStorage(
  storage: TrikStorage,
  id: string,
  updates: { body?: string; status?: 'draft' | 'done' }
): Promise<{ content: Content | null; action: 'body_updated' | 'status_changed' | 'both' | 'not_found' }> {
  const contentList = await getContentList(storage);
  const content = contentList.find((c) => c.id === id);
  if (!content) {
    return { content: null, action: 'not_found' };
  }

  let action: 'body_updated' | 'status_changed' | 'both';
  const hasBody = updates.body !== undefined;
  const hasStatus = updates.status !== undefined;

  if (hasBody && hasStatus) action = 'both';
  else if (hasBody) action = 'body_updated';
  else action = 'status_changed';

  if (hasBody) content.body = updates.body!;
  if (hasStatus) content.status = updates.status!;
  content.updatedAt = new Date().toISOString();

  await storage.set('content', contentList);
  return { content, action };
}

export interface ContentFilters {
  status?: 'draft' | 'done';
  type?: 'article' | 'linkedin' | 'x_post';
}

export function filterContent(
  contentList: Content[],
  filters: ContentFilters
): Content[] {
  let results = [...contentList];

  if (filters.status) {
    results = results.filter((c) => c.status === filters.status);
  }

  if (filters.type) {
    results = results.filter((c) => c.type === filters.type);
  }

  return results.sort((a, b) => b.updatedAt.localeCompare(a.updatedAt));
}
```

**Step 2: Commit**

```bash
git add src/storage.ts
git commit -m "feat: add typed storage helpers for sources, inspirations, and content"
```

---

### Task 1.4: Create Tool Stubs with Correct Zod Schemas

Refactor the scaffold's tool stubs to use the **factory pattern** (so they receive storage) and define proper Zod input schemas.

**Files:** Create all 11 tool files in `src/tools/`

Each tool exports a **factory function** that takes `TrikStorage` and returns the LangChain tool:

```typescript
// Pattern for every tool file:
import { tool } from '@langchain/core/tools';
import { z } from 'zod';
import type { TrikStorage } from '../storage.js';

export function createToolName(storage: TrikStorage) {
  return tool(
    async (input) => {
      // TODO: implement
      return JSON.stringify({ result: 'Not implemented' });
    },
    {
      name: 'toolName',
      description: '...',
      schema: z.object({ /* proper schema */ }),
    }
  );
}
```

**Step 1: Write `src/tools/sources.ts`**

```typescript
import { tool } from '@langchain/core/tools';
import { z } from 'zod';
import type { TrikStorage } from '../storage.js';

export function createAddSource(storage: TrikStorage) {
  return tool(
    async (input) => {
      // TODO: Phase 2
      return JSON.stringify({ result: 'Not implemented' });
    },
    {
      name: 'addSource',
      description:
        'Add a new content source (blog URL, single article URL, or newsletter sender email) to the tracked sources list.',
      schema: z.object({
        type: z.enum(['blog', 'article', 'newsletter']).describe('Type of source'),
        identifier: z.string().max(500).describe('URL for blog/article, or sender email for newsletter'),
        title: z.string().max(200).describe('Human-readable name for this source'),
      }),
    }
  );
}

export function createListSources(storage: TrikStorage) {
  return tool(
    async (input) => {
      // TODO: Phase 2
      return JSON.stringify({ result: 'Not implemented' });
    },
    {
      name: 'listSources',
      description: 'List all tracked content sources with optional type filter.',
      schema: z.object({
        type: z
          .enum(['blog', 'article', 'newsletter'])
          .optional()
          .describe('Filter by source type. Omit to list all.'),
      }),
    }
  );
}

export function createRemoveSource(storage: TrikStorage) {
  return tool(
    async (input) => {
      // TODO: Phase 2
      return JSON.stringify({ result: 'Not implemented' });
    },
    {
      name: 'removeSource',
      description: 'Remove a tracked content source by ID.',
      schema: z.object({
        sourceId: z.string().describe('ID of the source to remove'),
      }),
    }
  );
}
```

**Step 2: Write `src/tools/inspirations.ts`**

```typescript
import { tool } from '@langchain/core/tools';
import { z } from 'zod';
import type { TrikStorage } from '../storage.js';

export function createAddInspiration(storage: TrikStorage) {
  return tool(
    async (input) => {
      // TODO: Phase 3
      return JSON.stringify({ result: 'Not implemented' });
    },
    {
      name: 'addInspiration',
      description:
        'Store a new inspiration entry with title, description, URL, score, and source reference.',
      schema: z.object({
        sourceId: z.string().describe('ID of the parent source'),
        title: z.string().max(300).describe('Title of the inspiration'),
        description: z.string().max(1000).describe('Brief summary of the content'),
        url: z.string().url().max(500).describe('URL to the original content'),
        score: z.number().int().min(1).max(10).describe('Relevance score 1-10 based on user interests'),
      }),
    }
  );
}

export function createListInspirations(storage: TrikStorage) {
  return tool(
    async (input) => {
      // TODO: Phase 3
      return JSON.stringify({ result: 'Not implemented' });
    },
    {
      name: 'listInspirations',
      description:
        'Search and filter inspirations by query text, score range, date range, source, with sorting and limits.',
      schema: z.object({
        query: z.string().optional().describe('Search text to match against title and description'),
        minScore: z.number().int().min(1).max(10).optional().describe('Minimum score filter'),
        maxScore: z.number().int().min(1).max(10).optional().describe('Maximum score filter'),
        dateFrom: z.string().optional().describe('ISO date string - only include inspirations added after this date'),
        dateTo: z.string().optional().describe('ISO date string - only include inspirations added before this date'),
        sourceId: z.string().optional().describe('Filter by source ID'),
        sortBy: z.enum(['score', 'date']).optional().describe('Sort results by score (highest first) or date (newest first). Default: date'),
        limit: z.number().int().min(1).max(100).optional().describe('Max number of results to return. Default: 20'),
      }),
    }
  );
}

export function createGetInspiration(storage: TrikStorage) {
  return tool(
    async (input) => {
      // TODO: Phase 3
      return JSON.stringify({ result: 'Not implemented' });
    },
    {
      name: 'getInspiration',
      description: 'Get full details of a specific inspiration by ID.',
      schema: z.object({
        inspirationId: z.string().describe('ID of the inspiration to retrieve'),
      }),
    }
  );
}
```

**Step 3: Write `src/tools/content.ts`**

```typescript
import { tool } from '@langchain/core/tools';
import { z } from 'zod';
import type { TrikStorage } from '../storage.js';

export function createCreateContent(storage: TrikStorage) {
  return tool(
    async (input) => {
      // TODO: Phase 4
      return JSON.stringify({ result: 'Not implemented' });
    },
    {
      name: 'createContent',
      description:
        'Store a newly generated piece of content (article, LinkedIn post, or X post) as a draft.',
      schema: z.object({
        type: z.enum(['article', 'linkedin', 'x_post']).describe('Type of content to create'),
        title: z.string().max(300).describe('Title of the content'),
        body: z.string().describe('The full generated content body'),
        inspirationIds: z.array(z.string()).describe('IDs of inspirations this content is based on'),
        userPrompt: z.string().describe('The original user request/context that prompted this content'),
      }),
    }
  );
}

export function createListContent(storage: TrikStorage) {
  return tool(
    async (input) => {
      // TODO: Phase 4
      return JSON.stringify({ result: 'Not implemented' });
    },
    {
      name: 'listContent',
      description:
        'List created content filtered by status (draft/done) and/or content type.',
      schema: z.object({
        status: z.enum(['draft', 'done']).optional().describe('Filter by content status'),
        type: z.enum(['article', 'linkedin', 'x_post']).optional().describe('Filter by content type'),
      }),
    }
  );
}

export function createGetContent(storage: TrikStorage) {
  return tool(
    async (input) => {
      // TODO: Phase 4
      return JSON.stringify({ result: 'Not implemented' });
    },
    {
      name: 'getContent',
      description: 'Get full content details including body text by content ID.',
      schema: z.object({
        contentId: z.string().describe('ID of the content to retrieve'),
      }),
    }
  );
}

export function createUpdateContent(storage: TrikStorage) {
  return tool(
    async (input) => {
      // TODO: Phase 4
      return JSON.stringify({ result: 'Not implemented' });
    },
    {
      name: 'updateContent',
      description: 'Update content body text (iteration) or status (mark as done).',
      schema: z.object({
        contentId: z.string().describe('ID of the content to update'),
        body: z.string().optional().describe('New body text (for iteration/refinement)'),
        status: z.enum(['draft', 'done']).optional().describe('New status (use "done" to mark as complete)'),
      }),
    }
  );
}
```

**Step 4: Write `src/tools/gmail.ts`**

```typescript
import { tool } from '@langchain/core/tools';
import { z } from 'zod';
import type { TrikStorage } from '../storage.js';

// Config interface for Gmail credentials
export interface GmailConfig {
  get(key: string): string | undefined;
}

export function createFetchNewsletterEmails(storage: TrikStorage, config: GmailConfig) {
  return tool(
    async (input) => {
      // TODO: Phase 5
      return JSON.stringify({ result: 'Not implemented - Gmail integration pending' });
    },
    {
      name: 'fetchNewsletterEmails',
      description:
        'Fetch recent emails from a newsletter sender via Gmail API using OAuth2 credentials.',
      schema: z.object({
        sourceId: z.string().describe('ID of the newsletter source to fetch emails for'),
        maxResults: z.number().int().min(1).max(50).optional().describe('Max emails to fetch. Default: 10'),
        sinceDate: z.string().optional().describe('ISO date string - only fetch emails after this date'),
      }),
    }
  );
}
```

**Step 5: Commit**

```bash
git add src/tools/
git commit -m "feat: add tool stubs with factory pattern and proper Zod input schemas"
```

---

### Task 1.5: Create Agent Entry Point

**File:** Create `src/agent.ts`

Refactored from scaffold to use the factory pattern for tools.

**Step 1: Write agent.ts**

```typescript
import { ChatAnthropic } from '@langchain/anthropic';
import { createReactAgent } from '@langchain/langgraph/prebuilt';
import { wrapAgent, transferBackTool } from '@trikhub/sdk';
import type { TrikContext } from '@trikhub/sdk';
import { readFileSync } from 'node:fs';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

import { createAddSource, createListSources, createRemoveSource } from './tools/sources.js';
import { createAddInspiration, createListInspirations, createGetInspiration } from './tools/inspirations.js';
import { createCreateContent, createListContent, createGetContent, createUpdateContent } from './tools/content.js';
import { createFetchNewsletterEmails } from './tools/gmail.js';

const __dirname = dirname(fileURLToPath(import.meta.url));
const systemPrompt = readFileSync(join(__dirname, 'prompts/system.md'), 'utf-8');

export default wrapAgent((context: TrikContext) => {
  const { storage, config } = context;

  const model = new ChatAnthropic({
    modelName: 'claude-sonnet-4-6',
    anthropicApiKey: config.get('ANTHROPIC_API_KEY'),
  });

  const tools = [
    // Sources
    createAddSource(storage),
    createListSources(storage),
    createRemoveSource(storage),
    // Inspirations
    createAddInspiration(storage),
    createListInspirations(storage),
    createGetInspiration(storage),
    // Gmail
    createFetchNewsletterEmails(storage, config),
    // Content
    createCreateContent(storage),
    createListContent(storage),
    createGetContent(storage),
    createUpdateContent(storage),
    // Transfer back
    transferBackTool,
  ];

  return createReactAgent({
    llm: model,
    tools,
    messageModifier: systemPrompt,
  });
});
```

**Step 2: Write initial `src/prompts/system.md`**

```markdown
# Content Manager

You are a content curator and creator assistant. You help users gather inspiration from blogs, articles, and newsletters, and create content (articles, LinkedIn posts, X posts) in their voice.

## Your Tools

- **addSource** - Track a new blog, article, or newsletter
- **listSources** - See all tracked sources
- **removeSource** - Stop tracking a source
- **addInspiration** - Save an inspiring piece of content
- **listInspirations** - Search and browse inspirations
- **getInspiration** - Get details on a specific inspiration
- **fetchNewsletterEmails** - Check for new newsletter emails
- **createContent** - Save newly generated content as a draft
- **listContent** - Browse created content
- **getContent** - Read a specific piece of content
- **updateContent** - Refine content or mark it as done

## How You Work

- You are conversational. Never ask users for IDs â€” find items by name or description.
- When creating content, always use the user's voice guidelines and reference their inspirations.
- Score each inspiration 1-10 based on the user's interests.
- Present content for iteration before marking anything as done.

## Transfer Back

Use `transfer_back` when the user's request is outside your domain.
```

**Step 3: Commit**

```bash
git add src/agent.ts src/prompts/system.md
git commit -m "feat: add agent entry point with factory-pattern tool wiring"
```

---

### Task 1.6: Create Template Files

**Files:** Create `voice.md` and `interests.md` at project root as templates.

**Step 1: Write voice.md**

```markdown
# Voice Profile

Define your writing style for each content type. The AI will match this voice when generating content.

## Article Voice
<!-- Describe your blog article writing style -->
<!-- Example: "Professional but approachable. Use clear explanations with real-world examples. Avoid jargon unless explaining it. Write in first person. Keep paragraphs short (3-4 sentences max)." -->

## LinkedIn Post Voice
<!-- Describe your LinkedIn posting style -->
<!-- Example: "Thoughtful and insight-driven. Start with a hook question or bold statement. Use line breaks for readability. End with a question to drive engagement. Professional but human." -->

## X Post Voice
<!-- Describe your X/Twitter posting style -->
<!-- Example: "Concise and punchy. Use strong verbs. Include 1-2 relevant hashtags. Conversational tone. Under 280 characters when possible, thread for longer thoughts." -->
```

**Step 2: Write interests.md**

```markdown
# My Interests

Describe the topics, markets, and types of content you're interested in. The AI uses this to score how relevant each inspiration is to you (1-10).

## Topics
<!-- List your areas of interest -->
<!-- Example:
- AI and machine learning (especially applied AI, not pure research)
- Developer tools and DX
- Startup strategy and growth
- SaaS business models
-->

## Markets
<!-- What industries or markets do you follow? -->
<!-- Example:
- B2B SaaS
- Developer platforms
- AI/ML infrastructure
-->

## Content Preferences
<!-- What kind of content resonates with you? -->
<!-- Example:
- Deep technical tutorials (not surface-level listicles)
- Founder stories with real numbers
- Contrarian takes on industry trends
- Practical how-to guides
-->
```

**Step 3: Commit**

```bash
git add voice.md interests.md
git commit -m "docs: add template voice and interests files"
```

---

### Task 1.7: Install Dependencies & Verify Build

**Step 1: Run npm install**

```bash
npm install
```

**Step 2: Run build**

```bash
npm run build
```

Expected: Build succeeds (or we identify and fix any type issues).

**Note:** If `@trikhub/sdk` types are not available, we may need to create a local type declaration file at `src/trikhub-sdk.d.ts`. This is expected and should be handled in this step.

**Step 3: Initialize git repo and make final commit**

```bash
git init
git add -A
git commit -m "chore: complete Phase 1 - project foundation and scaffold"
```

**Phase 1 complete.** Safe to compact and continue.

---

## Phase 2: Sources Management (3 tools)

**Goal:** Implement `addSource`, `listSources`, `removeSource` with full storage integration.

**Stop point:** All three source tools are functional. Sources can be added, listed by type, and removed.

### Task 2.1: Implement addSource

**File:** Modify `src/tools/sources.ts`

**Step 1: Implement the addSource factory function**

Replace the TODO in `createAddSource` with:

```typescript
export function createAddSource(storage: TrikStorage) {
  return tool(
    async (input) => {
      const { source, status } = await addSourceToStorage(storage, {
        type: input.type,
        identifier: input.identifier,
        title: input.title,
      });
      return JSON.stringify({
        id: source.id,
        type: source.type,
        identifier: source.identifier,
        title: source.title,
        status,
        addedAt: source.addedAt,
      });
    },
    {
      name: 'addSource',
      description:
        'Add a new content source (blog URL, single article URL, or newsletter sender email) to the tracked sources list.',
      schema: z.object({
        type: z.enum(['blog', 'article', 'newsletter']).describe('Type of source'),
        identifier: z.string().max(500).describe('URL for blog/article, or sender email for newsletter'),
        title: z.string().max(200).describe('Human-readable name for this source'),
      }),
    }
  );
}
```

Add imports at top:
```typescript
import { addSourceToStorage, getSources, removeSourceFromStorage } from '../storage.js';
```

**Step 2: Commit**

```bash
git add src/tools/sources.ts
git commit -m "feat: implement addSource tool with storage integration"
```

---

### Task 2.2: Implement listSources

**File:** Modify `src/tools/sources.ts`

**Step 1: Implement the listSources factory function**

```typescript
export function createListSources(storage: TrikStorage) {
  return tool(
    async (input) => {
      let sources = await getSources(storage);
      const filterType = input.type || 'all';

      if (input.type) {
        sources = sources.filter((s) => s.type === input.type);
      }

      const summaries = sources.map((s) => ({
        id: s.id,
        type: s.type,
        identifier: s.identifier,
        title: s.title,
        addedAt: s.addedAt,
        lastScannedAt: s.lastScannedAt,
      }));

      return JSON.stringify({
        filterType,
        resultCount: summaries.length,
        sources: summaries,
      });
    },
    {
      name: 'listSources',
      description: 'List all tracked content sources with optional type filter.',
      schema: z.object({
        type: z
          .enum(['blog', 'article', 'newsletter'])
          .optional()
          .describe('Filter by source type. Omit to list all.'),
      }),
    }
  );
}
```

**Step 2: Commit**

```bash
git add src/tools/sources.ts
git commit -m "feat: implement listSources tool with type filtering"
```

---

### Task 2.3: Implement removeSource

**File:** Modify `src/tools/sources.ts`

**Step 1: Implement the removeSource factory function**

```typescript
export function createRemoveSource(storage: TrikStorage) {
  return tool(
    async (input) => {
      const { source, status } = await removeSourceFromStorage(storage, input.sourceId);
      return JSON.stringify({
        sourceId: input.sourceId,
        title: source?.title || 'unknown',
        status,
      });
    },
    {
      name: 'removeSource',
      description: 'Remove a tracked content source by ID.',
      schema: z.object({
        sourceId: z.string().describe('ID of the source to remove'),
      }),
    }
  );
}
```

**Step 2: Verify build**

```bash
npm run build
```

**Step 3: Commit**

```bash
git add src/tools/sources.ts
git commit -m "feat: implement removeSource tool - complete sources management"
```

**Phase 2 complete.** Safe to compact and continue.

---

## Phase 3: Inspirations Management (3 tools)

**Goal:** Implement `addInspiration`, `listInspirations`, `getInspiration` with full filtering and search.

**Stop point:** Inspirations can be added with scores, searched/filtered by multiple criteria, and retrieved individually.

### Task 3.1: Implement addInspiration

**File:** Modify `src/tools/inspirations.ts`

**Step 1: Implement**

```typescript
import { addInspirationToStorage, getInspirations, getInspirationById, filterInspirations } from '../storage.js';

export function createAddInspiration(storage: TrikStorage) {
  return tool(
    async (input) => {
      const { inspiration, status } = await addInspirationToStorage(storage, {
        sourceId: input.sourceId,
        title: input.title,
        description: input.description,
        url: input.url,
        score: input.score,
      });
      return JSON.stringify({
        id: inspiration.id,
        title: inspiration.title,
        score: inspiration.score,
        url: inspiration.url,
        status,
        addedAt: inspiration.addedAt,
      });
    },
    {
      name: 'addInspiration',
      description:
        'Store a new inspiration entry with title, description, URL, score, and source reference.',
      schema: z.object({
        sourceId: z.string().describe('ID of the parent source'),
        title: z.string().max(300).describe('Title of the inspiration'),
        description: z.string().max(1000).describe('Brief summary of the content'),
        url: z.string().url().max(500).describe('URL to the original content'),
        score: z.number().int().min(1).max(10).describe('Relevance score 1-10 based on user interests'),
      }),
    }
  );
}
```

**Step 2: Commit**

```bash
git add src/tools/inspirations.ts
git commit -m "feat: implement addInspiration tool with scoring"
```

---

### Task 3.2: Implement listInspirations

**File:** Modify `src/tools/inspirations.ts`

**Step 1: Implement**

```typescript
export function createListInspirations(storage: TrikStorage) {
  return tool(
    async (input) => {
      const allInspirations = await getInspirations(storage);
      const results = filterInspirations(allInspirations, {
        query: input.query,
        minScore: input.minScore,
        maxScore: input.maxScore,
        dateFrom: input.dateFrom,
        dateTo: input.dateTo,
        sourceId: input.sourceId,
        sortBy: input.sortBy || 'date',
        limit: input.limit || 20,
      });

      // Determine primary filter type for logging
      let filterType = 'all';
      if (input.query) filterType = 'byQuery';
      else if (input.minScore || input.maxScore) filterType = 'byScore';
      else if (input.dateFrom || input.dateTo) filterType = 'byDate';
      else if (input.sourceId) filterType = 'bySource';

      const summaries = results.map((i) => ({
        id: i.id,
        title: i.title,
        description: i.description,
        url: i.url,
        score: i.score,
        addedAt: i.addedAt,
        sourceId: i.sourceId,
      }));

      return JSON.stringify({
        filterType,
        resultCount: summaries.length,
        inspirations: summaries,
      });
    },
    {
      name: 'listInspirations',
      description:
        'Search and filter inspirations by query text, score range, date range, source, with sorting and limits.',
      schema: z.object({
        query: z.string().optional().describe('Search text to match against title and description'),
        minScore: z.number().int().min(1).max(10).optional().describe('Minimum score filter'),
        maxScore: z.number().int().min(1).max(10).optional().describe('Maximum score filter'),
        dateFrom: z.string().optional().describe('ISO date - only include inspirations added after this date'),
        dateTo: z.string().optional().describe('ISO date - only include inspirations added before this date'),
        sourceId: z.string().optional().describe('Filter by source ID'),
        sortBy: z.enum(['score', 'date']).optional().describe('Sort by score (highest first) or date (newest first). Default: date'),
        limit: z.number().int().min(1).max(100).optional().describe('Max results to return. Default: 20'),
      }),
    }
  );
}
```

**Step 2: Commit**

```bash
git add src/tools/inspirations.ts
git commit -m "feat: implement listInspirations tool with multi-criteria filtering"
```

---

### Task 3.3: Implement getInspiration

**File:** Modify `src/tools/inspirations.ts`

**Step 1: Implement**

```typescript
export function createGetInspiration(storage: TrikStorage) {
  return tool(
    async (input) => {
      const inspiration = await getInspirationById(storage, input.inspirationId);
      if (!inspiration) {
        return JSON.stringify({ error: 'Inspiration not found', inspirationId: input.inspirationId });
      }
      return JSON.stringify(inspiration);
    },
    {
      name: 'getInspiration',
      description: 'Get full details of a specific inspiration by ID.',
      schema: z.object({
        inspirationId: z.string().describe('ID of the inspiration to retrieve'),
      }),
    }
  );
}
```

**Step 2: Verify build**

```bash
npm run build
```

**Step 3: Commit**

```bash
git add src/tools/inspirations.ts
git commit -m "feat: implement getInspiration tool - complete inspirations management"
```

**Phase 3 complete.** Safe to compact and continue.

---

## Phase 4: Content Management (4 tools)

**Goal:** Implement `createContent`, `listContent`, `getContent`, `updateContent` for the full content lifecycle.

**Stop point:** Content can be created as drafts, listed/filtered, retrieved, iterated on, and marked as done.

### Task 4.1: Implement createContent

**File:** Modify `src/tools/content.ts`

**Step 1: Implement**

```typescript
import { addContentToStorage, getContentList, getContentById, updateContentInStorage, filterContent } from '../storage.js';

export function createCreateContent(storage: TrikStorage) {
  return tool(
    async (input) => {
      const content = await addContentToStorage(storage, {
        type: input.type,
        title: input.title,
        body: input.body,
        inspirationIds: input.inspirationIds,
        userPrompt: input.userPrompt,
      });
      return JSON.stringify({
        id: content.id,
        type: content.type,
        title: content.title,
        status: content.status,
        inspirationCount: content.inspirationIds.length,
        createdAt: content.createdAt,
      });
    },
    {
      name: 'createContent',
      description:
        'Store a newly generated piece of content (article, LinkedIn post, or X post) as a draft.',
      schema: z.object({
        type: z.enum(['article', 'linkedin', 'x_post']).describe('Type of content to create'),
        title: z.string().max(300).describe('Title of the content'),
        body: z.string().describe('The full generated content body'),
        inspirationIds: z.array(z.string()).describe('IDs of inspirations this content is based on'),
        userPrompt: z.string().describe('The original user request that prompted this content'),
      }),
    }
  );
}
```

**Step 2: Commit**

```bash
git add src/tools/content.ts
git commit -m "feat: implement createContent tool"
```

---

### Task 4.2: Implement listContent

**File:** Modify `src/tools/content.ts`

**Step 1: Implement**

```typescript
export function createListContent(storage: TrikStorage) {
  return tool(
    async (input) => {
      const allContent = await getContentList(storage);
      const results = filterContent(allContent, {
        status: input.status,
        type: input.type,
      });

      const summaries = results.map((c) => ({
        id: c.id,
        type: c.type,
        title: c.title,
        status: c.status,
        inspirationCount: c.inspirationIds.length,
        createdAt: c.createdAt,
        updatedAt: c.updatedAt,
      }));

      return JSON.stringify({
        statusFilter: input.status || 'all',
        typeFilter: input.type || 'all',
        resultCount: summaries.length,
        content: summaries,
      });
    },
    {
      name: 'listContent',
      description: 'List created content filtered by status (draft/done) and/or content type.',
      schema: z.object({
        status: z.enum(['draft', 'done']).optional().describe('Filter by content status'),
        type: z.enum(['article', 'linkedin', 'x_post']).optional().describe('Filter by content type'),
      }),
    }
  );
}
```

**Step 2: Commit**

```bash
git add src/tools/content.ts
git commit -m "feat: implement listContent tool with status and type filtering"
```

---

### Task 4.3: Implement getContent

**File:** Modify `src/tools/content.ts`

**Step 1: Implement**

```typescript
export function createGetContent(storage: TrikStorage) {
  return tool(
    async (input) => {
      const content = await getContentById(storage, input.contentId);
      if (!content) {
        return JSON.stringify({ error: 'Content not found', contentId: input.contentId });
      }
      return JSON.stringify(content);
    },
    {
      name: 'getContent',
      description: 'Get full content details including body text by content ID.',
      schema: z.object({
        contentId: z.string().describe('ID of the content to retrieve'),
      }),
    }
  );
}
```

**Step 2: Commit**

```bash
git add src/tools/content.ts
git commit -m "feat: implement getContent tool"
```

---

### Task 4.4: Implement updateContent

**File:** Modify `src/tools/content.ts`

**Step 1: Implement**

```typescript
export function createUpdateContent(storage: TrikStorage) {
  return tool(
    async (input) => {
      const { content, action } = await updateContentInStorage(
        storage,
        input.contentId,
        {
          body: input.body,
          status: input.status,
        }
      );

      if (!content) {
        return JSON.stringify({ error: 'Content not found', contentId: input.contentId });
      }

      return JSON.stringify({
        id: content.id,
        title: content.title,
        action,
        status: content.status,
        updatedAt: content.updatedAt,
      });
    },
    {
      name: 'updateContent',
      description: 'Update content body text (iteration) or status (mark as done).',
      schema: z.object({
        contentId: z.string().describe('ID of the content to update'),
        body: z.string().optional().describe('New body text (for iteration/refinement)'),
        status: z.enum(['draft', 'done']).optional().describe('New status (use "done" to mark as complete)'),
      }),
    }
  );
}
```

**Step 2: Verify build**

```bash
npm run build
```

**Step 3: Commit**

```bash
git add src/tools/content.ts
git commit -m "feat: implement updateContent tool - complete content management"
```

**Phase 4 complete.** Safe to compact and continue.

---

## Phase 5: Gmail Integration (1 tool)

**Goal:** Implement `fetchNewsletterEmails` with Gmail API OAuth2 authentication.

**Stop point:** Newsletter emails can be fetched via Gmail API, returning email metadata and extracted links.

### Task 5.1: Add googleapis Dependency

**Step 1: Install googleapis**

```bash
npm install googleapis
```

**Step 2: Commit**

```bash
git add package.json package-lock.json
git commit -m "chore: add googleapis dependency for Gmail API"
```

---

### Task 5.2: Create Gmail Client Helper

**File:** Create `src/gmail.ts`

**Step 1: Write Gmail client**

```typescript
import { google } from 'googleapis';

export interface GmailCredentials {
  clientId: string;
  clientSecret: string;
  refreshToken: string;
}

export function createGmailClient(credentials: GmailCredentials) {
  const oauth2Client = new google.auth.OAuth2(
    credentials.clientId,
    credentials.clientSecret
  );
  oauth2Client.setCredentials({
    refresh_token: credentials.refreshToken,
  });
  return google.gmail({ version: 'v1', auth: oauth2Client });
}

export interface EmailSummary {
  messageId: string;
  subject: string;
  from: string;
  date: string;
  snippet: string;
  links: string[];
}

export async function fetchEmailsFromSender(
  credentials: GmailCredentials,
  senderEmail: string,
  options: { maxResults?: number; sinceDate?: string } = {}
): Promise<EmailSummary[]> {
  const gmail = createGmailClient(credentials);
  const maxResults = options.maxResults || 10;

  // Build Gmail search query
  let query = `from:${senderEmail}`;
  if (options.sinceDate) {
    // Gmail uses YYYY/MM/DD format for after: filter
    const date = new Date(options.sinceDate);
    const formatted = `${date.getFullYear()}/${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')}`;
    query += ` after:${formatted}`;
  }

  const listResponse = await gmail.users.messages.list({
    userId: 'me',
    q: query,
    maxResults,
  });

  const messages = listResponse.data.messages || [];
  const results: EmailSummary[] = [];

  for (const msg of messages) {
    const detail = await gmail.users.messages.get({
      userId: 'me',
      id: msg.id!,
      format: 'full',
    });

    const headers = detail.data.payload?.headers || [];
    const subject = headers.find((h) => h.name === 'Subject')?.value || '';
    const from = headers.find((h) => h.name === 'From')?.value || '';
    const date = headers.find((h) => h.name === 'Date')?.value || '';
    const snippet = detail.data.snippet || '';

    // Extract links from the email body
    const links = extractLinksFromPayload(detail.data.payload);

    results.push({
      messageId: msg.id!,
      subject,
      from,
      date,
      snippet,
      links: [...new Set(links)], // deduplicate
    });
  }

  return results;
}

function extractLinksFromPayload(payload: any): string[] {
  const links: string[] = [];
  if (!payload) return links;

  const body = getBodyFromPayload(payload);
  if (body) {
    // Extract URLs from HTML/text content
    const urlRegex = /https?:\/\/[^\s<>"{}|\\^`\[\]]+/g;
    const matches = body.match(urlRegex) || [];
    // Filter out common non-article URLs
    const filtered = matches.filter(
      (url) =>
        !url.includes('unsubscribe') &&
        !url.includes('mailto:') &&
        !url.includes('list-manage') &&
        !url.includes('tracking') &&
        !url.includes('beacon') &&
        !url.includes('pixel')
    );
    links.push(...filtered);
  }

  return links;
}

function getBodyFromPayload(payload: any): string {
  if (payload.body?.data) {
    return Buffer.from(payload.body.data, 'base64').toString('utf-8');
  }

  if (payload.parts) {
    // Prefer HTML part, fall back to plain text
    const htmlPart = payload.parts.find(
      (p: any) => p.mimeType === 'text/html'
    );
    if (htmlPart?.body?.data) {
      return Buffer.from(htmlPart.body.data, 'base64').toString('utf-8');
    }

    const textPart = payload.parts.find(
      (p: any) => p.mimeType === 'text/plain'
    );
    if (textPart?.body?.data) {
      return Buffer.from(textPart.body.data, 'base64').toString('utf-8');
    }

    // Recursive for multipart
    for (const part of payload.parts) {
      const result = getBodyFromPayload(part);
      if (result) return result;
    }
  }

  return '';
}
```

**Step 2: Commit**

```bash
git add src/gmail.ts
git commit -m "feat: add Gmail API client with OAuth2 and email parsing"
```

---

### Task 5.3: Implement fetchNewsletterEmails Tool

**File:** Modify `src/tools/gmail.ts`

**Step 1: Implement the tool**

```typescript
import { tool } from '@langchain/core/tools';
import { z } from 'zod';
import type { TrikStorage } from '../storage.js';
import { getSources, updateSourceScanTime } from '../storage.js';
import { fetchEmailsFromSender } from '../gmail.js';

export interface TrikConfig {
  get(key: string): string | undefined;
}

export function createFetchNewsletterEmails(storage: TrikStorage, config: TrikConfig) {
  return tool(
    async (input) => {
      // Get the source to find the sender email
      const sources = await getSources(storage);
      const source = sources.find((s) => s.id === input.sourceId);

      if (!source) {
        return JSON.stringify({
          error: 'Source not found',
          sourceId: input.sourceId,
          status: 'error',
        });
      }

      if (source.type !== 'newsletter') {
        return JSON.stringify({
          error: 'Source is not a newsletter',
          sourceId: input.sourceId,
          sourceType: source.type,
          status: 'error',
        });
      }

      // Get Gmail credentials from config
      const clientId = config.get('gmail_client_id');
      const clientSecret = config.get('gmail_client_secret');
      const refreshToken = config.get('gmail_refresh_token');

      if (!clientId || !clientSecret || !refreshToken) {
        return JSON.stringify({
          error: 'Gmail credentials not configured. Set gmail_client_id, gmail_client_secret, and gmail_refresh_token in trik config.',
          status: 'auth_error',
        });
      }

      try {
        const emails = await fetchEmailsFromSender(
          { clientId, clientSecret, refreshToken },
          source.identifier,
          {
            maxResults: input.maxResults,
            sinceDate: input.sinceDate || source.lastScannedAt || undefined,
          }
        );

        // Update the source's last scanned time
        await updateSourceScanTime(storage, source.id);

        if (emails.length === 0) {
          return JSON.stringify({
            senderEmail: source.identifier,
            emailCount: 0,
            status: 'no_emails',
            emails: [],
          });
        }

        return JSON.stringify({
          senderEmail: source.identifier,
          emailCount: emails.length,
          status: 'success',
          emails: emails.map((e) => ({
            subject: e.subject,
            date: e.date,
            snippet: e.snippet,
            links: e.links,
          })),
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return JSON.stringify({
          error: message,
          senderEmail: source.identifier,
          emailCount: 0,
          status: 'error',
        });
      }
    },
    {
      name: 'fetchNewsletterEmails',
      description:
        'Fetch recent emails from a newsletter sender via Gmail API using OAuth2 credentials.',
      schema: z.object({
        sourceId: z.string().describe('ID of the newsletter source to fetch emails for'),
        maxResults: z.number().int().min(1).max(50).optional().describe('Max emails to fetch. Default: 10'),
        sinceDate: z.string().optional().describe('ISO date - only fetch emails after this date'),
      }),
    }
  );
}
```

**Step 2: Verify build**

```bash
npm run build
```

**Step 3: Commit**

```bash
git add src/tools/gmail.ts
git commit -m "feat: implement fetchNewsletterEmails with Gmail API OAuth2"
```

**Phase 5 complete.** Safe to compact and continue.

---

## Phase 6: Agent System Prompt & Polish

**Goal:** Write the comprehensive system prompt that makes the agent truly conversational, integrate voice.md and interests.md, validate the manifest, and do final polish.

**Stop point:** Trik is complete and ready for `trik lint` validation.

### Task 6.1: Write Full System Prompt

**File:** Modify `src/prompts/system.md`

**Step 1: Write the comprehensive system prompt**

The system prompt should cover:
- Agent identity and personality
- How to handle each type of user request conversationally
- Voice and interests integration instructions
- Workflow guidelines for each feature
- Conversational patterns (never ask for IDs, find by name)
- Scoring guidelines
- Content creation workflow with iteration

Write a full system prompt (~800-1200 words) that covers all of the above. The prompt should reference the user's voice.md and interests.md data that will be dynamically injected.

Key sections to include:
1. Identity: "You are a content curator and creator assistant"
2. Core principle: "Never ask users for IDs. Find items by name, title, or description."
3. Source management guidelines
4. Inspiration scoring: "When adding inspirations, score them 1-10 based on the user's interests"
5. Content creation workflow: fetch inspirations -> read voice profile -> generate -> store as draft -> present for review
6. Iteration workflow: present content -> accept feedback -> update -> repeat until user approves
7. Trend analysis: how to identify patterns across inspirations
8. Transfer back guidelines

**Step 2: Commit**

```bash
git add src/prompts/system.md
git commit -m "feat: write comprehensive conversational system prompt"
```

---

### Task 6.2: Dynamic System Prompt Builder

**File:** Modify `src/agent.ts`

**Step 1: Update agent to dynamically inject voice and interests into system prompt**

Instead of just reading the static system.md, the agent should:
1. Read the base system prompt from system.md
2. Read voice and interests from storage
3. Append them to the system prompt as context

```typescript
// In agent.ts, modify the wrapAgent callback:
const baseSystemPrompt = readFileSync(join(__dirname, 'prompts/system.md'), 'utf-8');

// Build dynamic system prompt with voice and interests
const voice = await storage.get('voice') as string || '';
const interests = await storage.get('interests') as string || '';

let systemPrompt = baseSystemPrompt;
if (voice) {
  systemPrompt += `\n\n## User's Voice Profile\n\n${voice}`;
}
if (interests) {
  systemPrompt += `\n\n## User's Interests\n\n${interests}`;
}
```

**Note:** This may require making the wrapAgent callback async. If the SDK doesn't support async factory, we may need to load voice/interests differently (e.g., through a dedicated tool the agent calls at startup). Adapt as needed based on SDK behavior.

**Step 2: Commit**

```bash
git add src/agent.ts
git commit -m "feat: dynamic system prompt with voice and interests injection"
```

---

### Task 6.3: Validate Manifest

**Step 1: Run manifest validation through TrikHub MCP**

Use the `validate_manifest` MCP tool with the content of `manifest.json`.

**Step 2: Fix any validation errors or warnings**

**Step 3: Commit fixes if any**

```bash
git add manifest.json
git commit -m "fix: address manifest validation issues"
```

---

### Task 6.4: Final Build & Lint

**Step 1: Clean build**

```bash
npm run clean && npm run build
```

**Step 2: Run trik lint (if available)**

```bash
npx trik lint .
```

**Step 3: Final commit**

```bash
git add -A
git commit -m "chore: complete Phase 6 - agent prompt, validation, and polish"
```

**Phase 6 complete. Trik implementation is done.**

---

## Post-Implementation Notes

### Testing Approach
Since this is a conversational trik, manual testing through the TrikHub platform is the primary testing method:
1. Install the trik locally
2. Test each conversational flow from the "Classic Prompts" section in the design doc
3. Verify storage persistence across sessions

### Known Assumptions to Verify
1. `TrikStorage` API shape (`.get()`, `.set()`) - may differ from what we assumed
2. `TrikConfig` API shape (`.get()`) - may differ
3. Whether `wrapAgent` callback can be async (for dynamic system prompt)
4. Whether the agent has built-in web fetch capability (needed for blog scanning)
5. The system prompt file path resolution at runtime vs build time

### Files Changed Summary
| Phase | Files |
|-------|-------|
| 1 | `manifest.json`, `package.json`, `tsconfig.json`, `.gitignore`, `.trikhub/secrets.json`, `src/types.ts`, `src/storage.ts`, `src/tools/sources.ts`, `src/tools/inspirations.ts`, `src/tools/content.ts`, `src/tools/gmail.ts`, `src/agent.ts`, `src/prompts/system.md`, `voice.md`, `interests.md` |
| 2 | `src/tools/sources.ts` |
| 3 | `src/tools/inspirations.ts` |
| 4 | `src/tools/content.ts` |
| 5 | `package.json`, `src/gmail.ts`, `src/tools/gmail.ts` |
| 6 | `src/prompts/system.md`, `src/agent.ts`, `manifest.json` |
